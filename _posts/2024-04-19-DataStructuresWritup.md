---
title: Data Structures Write Up
layout: post
type: tangibles
permalink: /datastrucwriteup
---

## Collections

#### Unique collection/table in database, display rows and columns in the table of the SQLite database.

For this portion, I just used the users database already given in the teacher portfolio

Users Database:

<img src="images/databaseinteraction.png" alt="sigma">
<br>
<br>
The image above shows the sqlite database for users and the information stored in its columns:

- Name: The name of the user

- UID: Unique username for user

- Date of Birth: User's birthday
<br>
<br>

#### Unique code that was created to initialize table and create test data.

Below is the code from the users model. 
<img src="images/databaseinteractcode.png" alt="sigmacool">
<br>
<br>
The User model initializes the database and populates the 'user' table with test data in line 235,
<br>
with `User(name='Jayden Chen', uid ='Coolawesomesauce'...)` using Flask and SQLAlchemy.
<br>

## Lists & Dictionaries

#### A list as extracted from database as Python objects.


<img src="images/Screenshot 2024-05-09 at 9.11.52 AM.png" alt="rizz">

<br>
<br>
List and dictionaries for users when extracted from database.
<br>
<br>

#### Two distinct examples of dictionaries, show Keys/Values using debugger.


<img src="images/Screenshot 2024-04-19 at 2.01.55 PM.png" alt="gyat">

<br>
The read method constructs a dictionary containing information about an object, including its ID, user ID, note, image filename, and base64-encoded image data. Using a debugger, we can confirm that the dictionary captures these values accurately for different instances of the class, ensuring the proper representation of object data. The distance generated by this segment is as following:

    
    "id": 1,

    "userID": "user123",

    "note": "This is a test note",

    "image": "test.jpg",

    "base64": "VGhpcyBpcyBhIHRlc3QgaW1hZ2Uu"


<br>
<br>

## APIs and JSON

#### Python API code definition for request and response using GET, POST, UPDATE methods. Discuss algorithmic condition used to direct request to appropriate Python method based on request method.


<img src="images/Screenshot 2024-04-19 at 2.04.34 PM.png" alt="mewing">

<br>
<br>
This code is for handling a “POST” request in a Python API. It first checks if the request contains the required data, like a note and user ID. If everything is okay, it creates a new entry in the database with this data. If successful, it returns the newly created entry. If there’s an issue, like missing data or a duplicate user ID, it returns an error message instead. It’s like a form where you fill in some details, and when you submit it, it saves the information you provided. If something’s wrong with what you filled out, it tells you so you can fix it.
<br>
<br>

#### Algorithmic conditions used to validate data on a POST condition.



<img src="images/Screenshot 2024-04-19 at 2.05.29 PM.png" alt="mewing">

<br>
<br>
This code snippet first checks if the user ID (uid) is either missing or less than 2 characters long. If it is, it returns an error message indicating that the user ID is invalid. Then, it retrieves additional data like the date of question (doq) and parent post ID from the request body. After that, it sets up a new Post object with the provided data. It also performs additional error checking, such as converting the date format. If there’s an error during this process, it returns an error message indicating the issue. Overall, this code ensures that the data provided in the POST request is valid and properly formatted before proceeding with creating a new post object.
<br>
<br>

#### URL request and Body requirements for GET, POST, and UPDATE methods.



<img src="images/Screenshot 2024-04-19 at 2.06.30 PM.png" alt="edging">

<br>
<br>
The algorithmic condition for directing requests to appropriate Python methods is based on mapping HTTP to class methods with matching names essentially. When a request is made, the framework checks the HTTP method (GET, POST, PUT) and automatically uses the corresponding method defined within the resource class (like for us get, post, put), which is makin sure each request is handled efficiently and directed to the correct method based on intended action specified by the HTTP.


<br>

#### In Postman, show the JSON response data for 200 success conditions on GET, POST, and UPDATE methods.



<img src="images/Screenshot 2024-04-19 at 2.08.21 PM.png" alt="siuuu">

<br>
<br>
These images shows the URL endpoints for performing GET, POST, and UPDATE requests, along with the required parameters/body content needed for each request. It helps users understand how to structure their requests correctly to interact with the API. 
<br>
These images display the JSON response data returned by the API when the request is successful (status code 200) for GET, POST, and UPDATE methods. It provides insight into the format and content of the response that users can expect when their requests are processed successfully.


<br>

#### In Postman, show the JSON response for error for 404 when providing an unknown user ID to a UPDATE request.



<img src="images/Screenshot 2024-04-19 at 2.08.43 PM.png" alt="SPEED">
<br>
<br>
This image showcases the JSON response returned by the API when the request fails due to a missing body in a POST request (status code 400). It informs users about the specific error that occurred and potentially provides guidance on how to resolve the issue, such as including the required body content.

This image illustrates the JSON response generated by the API when the requested resource (user ID) is not found, resulting in a 404 error status code. It informs users that the provided user ID does not exist in the system and prompts them to verify the correctness of the ID they are attempting to update.
<br>
<br>

## Frontend

#### Response of JSON objects from fetch of GET, POST, and UPDATE methods in frontend.


<img src="images/Screenshot 2024-04-19 at 2.16.20 PM.png" alt="tinga">

The screenshot above is from a different project, as the backend for this project did not require the usage of a database, but this project meets the requirement by providing a Flask endpoint (/api/prizepicks/predicted-stats) that responds to POST requests from the frontend. The endpoint fetches predicted stats for a given matchup number using a machine learning model and compares them with the actual results obtained from a database. The comparison results are then returned as JSON objects to the frontend, enabling interaction with the user's betting choices.